/**
 * Image Service
 *
 * Mikro ERP'den √ºr√ºn resimlerini indirir, optimize eder ve kaydeder
 */

import mssql from 'mssql';
import sharp from 'sharp';
import fs from 'fs/promises';
import path from 'path';
import { exec } from 'child_process';
import { config } from '../config';
import mikroService from './mikroFactory.service';

interface ImageDownloadResult {
  success: boolean;
  localPath?: string;
  size?: number;
  error?: string;
  skipped?: boolean;
  skipReason?: string;
}

interface ImageSyncStats {
  downloaded: number;
  skipped: number;
  failed: number;
  warnings: Array<{
    type: string;
    productCode: string;
    productName: string;
    message: string;
    size?: number;
  }>;
}

class ImageService {
  private readonly MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10 MB
  private readonly RESIZE_WIDTH = 1200;
  private readonly RESIZE_HEIGHT = 1200;
  private readonly QUALITY = 85;
  private readonly UPLOAD_DIR = path.join(process.cwd(), 'uploads', 'products');
  private readonly PROCESSING_TIMEOUT = 60000; // 60 saniye timeout (BMP/TIFF i√ßin)

  /**
   * Upload klas√∂r√ºn√º olu≈ütur
   */
  async ensureUploadDir(): Promise<void> {
    try {
      await fs.access(this.UPLOAD_DIR);
    } catch {
      await fs.mkdir(this.UPLOAD_DIR, { recursive: true });
      console.log(`üìÅ Upload klas√∂r√º olu≈üturuldu: ${this.UPLOAD_DIR}`);
    }
  }

  /**
   * ImageMagick ile resmi d√∂n√º≈üt√ºr (fallback) - ger√ßek timeout ile
   */
  private async convertWithImageMagick(
    inputPath: string,
    outputPath: string
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const command = `convert "${inputPath}" -resize ${this.RESIZE_WIDTH}x${this.RESIZE_HEIGHT}\\> -quality ${this.QUALITY} "${outputPath}"`;

      const childProcess = exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });

      // Timeout: Child process'i kill et
      const timeout = setTimeout(() => {
        childProcess.kill('SIGKILL'); // Force kill
        reject(new Error('ImageMagick timeout - process killed'));
      }, this.PROCESSING_TIMEOUT);

      // Cleanup
      childProcess.on('exit', () => {
        clearTimeout(timeout);
      });
    });
  }

  /**
   * Mikro'dan bir √ºr√ºn√ºn resmini indir
   */
  async downloadImageFromMikro(
    productCode: string,
    productGuid: string
  ): Promise<ImageDownloadResult> {
    try {
      // Mock mode'da √ßalƒ±≈üma
      if (config.useMockMikro) {
        return {
          success: false,
          skipped: true,
          skipReason: 'Mock mode - resim indirme devre dƒ±≈üƒ±',
        };
      }

      // Real MikroService kullandƒ±ƒüƒ±mƒ±zdan emin ol
      const realMikroService = mikroService as any;
      if (!realMikroService.pool || !realMikroService.connect) {
        return {
          success: false,
          skipped: true,
          skipReason: 'Ger√ßek Mikro service kullanƒ±lmƒ±yor',
        };
      }

      // Mikro'ya baƒülan
      await realMikroService.connect();

      // Resmi sorgula
      const query = `
        SELECT Data, DATALENGTH(Data) as DataSize
        FROM mye_ImageData
        WHERE Record_uid = @guid
          AND TableID = 13
      `;

      const request = (mikroService as any).pool!.request();
      request.input('guid', mssql.UniqueIdentifier, productGuid);

      const result = await request.query(query);

      if (result.recordset.length === 0) {
        return {
          success: false,
          skipped: true,
          skipReason: 'Mikro\'da resim yok',
        };
      }

      const imageData = result.recordset[0];
      const dataSize = imageData.DataSize;

      // Boyut kontrol√º
      if (dataSize > this.MAX_IMAGE_SIZE) {
        const sizeMB = (dataSize / 1024 / 1024).toFixed(2);
        return {
          success: false,
          skipped: true,
          skipReason: `Resim √ßok b√ºy√ºk (${sizeMB} MB > ${this.MAX_IMAGE_SIZE / 1024 / 1024} MB limit)`,
          size: dataSize,
        };
      }

      // Binary data'yƒ± al
      const buffer = imageData.Data as Buffer;

      const filename = `${productCode}.jpg`;
      const filepath = path.join(this.UPLOAD_DIR, filename);

      // 1. √ñnce Sharp ile dene
      try {
        // Timeout ile Sharp i≈ülemi
        const sharpPromise = sharp(buffer)
          .resize(this.RESIZE_WIDTH, this.RESIZE_HEIGHT, {
            fit: 'inside',
            withoutEnlargement: true,
          })
          .jpeg({
            quality: this.QUALITY,
            progressive: true,
          })
          .toFile(filepath);

        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Image processing timeout')), this.PROCESSING_TIMEOUT);
        });

        await Promise.race([sharpPromise, timeoutPromise]);

        // Ba≈üarƒ±lƒ±!
        const stats = await fs.stat(filepath);
        console.log(`‚úÖ Resim kaydedildi (Sharp): ${productCode} (${(stats.size / 1024).toFixed(0)} KB)`);

        return {
          success: true,
          localPath: `/uploads/products/${filename}`,
          size: stats.size,
        };
      } catch (sharpError: any) {
        console.log(`‚ö†Ô∏è Sharp ba≈üarƒ±sƒ±z (${productCode}): ${sharpError.message} - ImageMagick deneniyor...`);

        // 2. Sharp ba≈üarƒ±sƒ±z, ImageMagick dene
        try {
          // √ñnce raw dosyayƒ± kaydet
          const tempPath = path.join(this.UPLOAD_DIR, `${productCode}.tmp`);
          await fs.writeFile(tempPath, buffer);

          // ImageMagick ile d√∂n√º≈üt√ºr
          await this.convertWithImageMagick(tempPath, filepath);

          // Temp dosyayƒ± sil
          await fs.unlink(tempPath);

          // Ba≈üarƒ±lƒ±!
          const stats = await fs.stat(filepath);
          console.log(`‚úÖ Resim kaydedildi (ImageMagick): ${productCode} (${(stats.size / 1024).toFixed(0)} KB)`);

          return {
            success: true,
            localPath: `/uploads/products/${filename}`,
            size: stats.size,
          };
        } catch (imageMagickError: any) {
          // Temp dosyayƒ± temizle (varsa)
          try {
            const tempPath = path.join(this.UPLOAD_DIR, `${productCode}.tmp`);
            await fs.unlink(tempPath);
          } catch {}

          // Her iki y√∂ntem de ba≈üarƒ±sƒ±z
          console.error(`‚ùå T√ºm y√∂ntemler ba≈üarƒ±sƒ±z (${productCode}):`, imageMagickError.message);

          return {
            success: false,
            skipped: true,
            skipReason: `Format d√∂n√º≈üt√ºrme ba≈üarƒ±sƒ±z: ${imageMagickError.message}`,
          };
        }
      }
    } catch (error: any) {
      console.error(`‚ùå Resim indirme hatasƒ± (${productCode}):`, error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * T√ºm √ºr√ºnlerin resimlerini sync et (sadece resmi olmayanlara)
   */
  async syncAllImages(
    products: Array<{ id: string; mikroCode: string; name: string; guid: string; imageUrl: string | null }>,
    syncLogId?: string
  ): Promise<ImageSyncStats> {
    await this.ensureUploadDir();

    const stats: ImageSyncStats = {
      downloaded: 0,
      skipped: 0,
      failed: 0,
      warnings: [],
    };

    // Sadece resmi olmayan √ºr√ºnleri al
    const productsWithoutImage = products.filter(p => !p.imageUrl);
    const totalImages = productsWithoutImage.length;

    console.log(`\nüì∏ Resim senkronizasyonu ba≈ülƒ±yor: ${totalImages} √ºr√ºn`);

    // SyncLog'a toplam resim sayƒ±sƒ±nƒ± kaydet
    if (syncLogId) {
      const { prisma } = await import('../utils/prisma');
      await prisma.syncLog.update({
        where: { id: syncLogId },
        data: {
          details: {
            totalImages,
          },
        },
      });
    }

    for (const product of productsWithoutImage) {
      const result = await this.downloadImageFromMikro(product.mikroCode, product.guid);

      if (result.success && result.localPath) {
        stats.downloaded++;

        // PostgreSQL'de imageUrl g√ºncelle
        try {
          const { prisma } = await import('../utils/prisma');
          await prisma.product.update({
            where: { id: product.id },
            data: { imageUrl: result.localPath },
          });
        } catch (error: any) {
          console.error(`‚ùå ImageUrl g√ºncelleme hatasƒ± (${product.mikroCode}):`, error.message);
        }
      } else if (result.skipped) {
        stats.skipped++;

        // Uyarƒ± ekle (sadece boyut nedeniyle atlananlar i√ßin)
        if (result.size && result.size > this.MAX_IMAGE_SIZE) {
          stats.warnings.push({
            type: 'IMAGE_TOO_LARGE',
            productCode: product.mikroCode,
            productName: product.name,
            message: result.skipReason || 'Resim √ßok b√ºy√ºk',
            size: result.size,
          });
        }
      } else {
        stats.failed++;

        // Ger√ßek hata varsa uyarƒ± ekle
        if (result.error) {
          stats.warnings.push({
            type: 'IMAGE_DOWNLOAD_ERROR',
            productCode: product.mikroCode,
            productName: product.name,
            message: result.error,
          });
        }
      }

      // Her 10 √ºr√ºnde bir progress g√∂ster ve SyncLog'u g√ºncelle
      const processed = stats.downloaded + stats.skipped + stats.failed;
      if (processed % 10 === 0) {
        console.log(`  üìä ƒ∞lerleme: ${stats.downloaded} indirildi, ${stats.skipped} atlandƒ±, ${stats.failed} hata`);

        // SyncLog'u g√ºncelle
        if (syncLogId) {
          try {
            const { prisma } = await import('../utils/prisma');
            await prisma.syncLog.update({
              where: { id: syncLogId },
              data: {
                imagesDownloaded: stats.downloaded,
                imagesSkipped: stats.skipped,
                imagesFailed: stats.failed,
              },
            });
          } catch (error) {
            // G√ºncelleme hatasƒ±nƒ± logla ama devam et
            console.error('SyncLog g√ºncelleme hatasƒ±:', error);
          }
        }
      }
    }

    console.log(`\nüì∏ Resim senkronizasyonu tamamlandƒ±:`);
    console.log(`  ‚úÖ ƒ∞ndirilen: ${stats.downloaded}`);
    console.log(`  ‚è≠Ô∏è Atlanan: ${stats.skipped}`);
    console.log(`  ‚ùå Hatalƒ±: ${stats.failed}`);
    console.log(`  ‚ö†Ô∏è Uyarƒ± sayƒ±sƒ±: ${stats.warnings.length}`);

    return stats;
  }

  /**
   * Bir √ºr√ºn√ºn resmini sil
   */
  async deleteProductImage(imageUrl: string): Promise<void> {
    try {
      const filename = path.basename(imageUrl);
      const filepath = path.join(this.UPLOAD_DIR, filename);
      await fs.unlink(filepath);
      console.log(`üóëÔ∏è Resim silindi: ${filename}`);
    } catch (error: any) {
      console.error(`‚ùå Resim silme hatasƒ±:`, error.message);
    }
  }
}

export default new ImageService();
