/**
 * Image Service
 *
 * Mikro ERP'den √ºr√ºn resimlerini indirir, optimize eder ve kaydeder
 */

import mssql from 'mssql';
import fs from 'fs/promises';
import path from 'path';
import { exec } from 'child_process';
import { config } from '../config';
import mikroService from './mikroFactory.service';

interface ImageDownloadResult {
  success: boolean;
  localPath?: string;
  size?: number;
  error?: string;
  skipped?: boolean;
  skipReason?: string;
}

interface ImageSyncStats {
  downloaded: number;
  skipped: number;
  failed: number;
  warnings: Array<{
    type: string;
    productCode: string;
    productName: string;
    message: string;
    size?: number;
  }>;
}

class ImageService {
  private readonly MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10 MB
  private readonly RESIZE_WIDTH = 1200;
  private readonly RESIZE_HEIGHT = 1200;
  private readonly QUALITY = 85;
  private readonly UPLOAD_DIR = path.join(process.cwd(), 'uploads', 'products');
  private readonly PROCESSING_TIMEOUT = 10000; // 10 saniye timeout (Sharp i√ßin)

  /**
   * Upload klas√∂r√ºn√º olu≈ütur
   */
  async ensureUploadDir(): Promise<void> {
    try {
      await fs.access(this.UPLOAD_DIR);
    } catch {
      await fs.mkdir(this.UPLOAD_DIR, { recursive: true });
      console.log(`üìÅ Upload klas√∂r√º olu≈üturuldu: ${this.UPLOAD_DIR}`);
    }
  }

  /**
   * ImageMagick ile resmi d√∂n√º≈üt√ºr (fallback) - g√ºvenli ve optimize
   */
  private async convertWithImageMagick(
    inputPath: string,
    outputPath: string,
    width: number = this.RESIZE_WIDTH,
    height: number = this.RESIZE_HEIGHT
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      // G√ºvenli ImageMagick parametreleri:
      // -limit memory 256MB: Bell–µ–∫ limiti (CPU donmasƒ±nƒ± √∂nler)
      // -limit thread 1: Tek thread (daha stabil)
      // -strip: Metadata kaldƒ±r (daha hƒ±zlƒ±)
      // -thumbnail: Daha hƒ±zlƒ± resize (resize yerine)
      const command = `convert "${inputPath}" ` +
        `-limit memory 256MB -limit thread 1 ` +
        `-strip ` +
        `-thumbnail ${width}x${height}\\> ` +
        `-quality ${this.QUALITY} ` +
        `"${outputPath}"`;

      const childProcess = exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });

      // 30 saniye timeout (60 yerine daha kƒ±sa)
      const timeout = setTimeout(() => {
        childProcess.kill('SIGKILL');
        reject(new Error('ImageMagick timeout'));
      }, 30000);

      childProcess.on('exit', () => {
        clearTimeout(timeout);
      });
    });
  }

  /**
   * Mikro'dan bir √ºr√ºn√ºn resmini indir
   */
  async downloadImageFromMikro(
    productCode: string,
    productGuid: string
  ): Promise<ImageDownloadResult> {
    try {
      // Mock mode'da √ßalƒ±≈üma
      if (config.useMockMikro) {
        return {
          success: false,
          skipped: true,
          skipReason: 'Mock mode - resim indirme devre dƒ±≈üƒ±',
        };
      }

      // Real MikroService kullandƒ±ƒüƒ±mƒ±zdan emin ol
      const realMikroService = mikroService as any;
      if (!realMikroService.pool || !realMikroService.connect) {
        return {
          success: false,
          skipped: true,
          skipReason: 'Ger√ßek Mikro service kullanƒ±lmƒ±yor',
        };
      }

      // Mikro'ya baƒülan
      await realMikroService.connect();

      // Resmi sorgula
      const query = `
        SELECT Data, DATALENGTH(Data) as DataSize
        FROM mye_ImageData
        WHERE Record_uid = @guid
          AND TableID = 13
      `;

      const request = (mikroService as any).pool!.request();
      request.input('guid', mssql.UniqueIdentifier, productGuid);

      const result = await request.query(query);

      if (result.recordset.length === 0) {
        return {
          success: false,
          skipped: true,
          skipReason: 'Mikro\'da resim yok',
        };
      }

      const imageData = result.recordset[0];
      const dataSize = imageData.DataSize;

      // Boyut kontrol√º
      if (dataSize > this.MAX_IMAGE_SIZE) {
        const sizeMB = (dataSize / 1024 / 1024).toFixed(2);
        return {
          success: false,
          skipped: true,
          skipReason: `Resim √ßok b√ºy√ºk (${sizeMB} MB > ${this.MAX_IMAGE_SIZE / 1024 / 1024} MB limit)`,
          size: dataSize,
        };
      }

      // Binary data'yƒ± al
      const buffer = imageData.Data as Buffer;

      const filename = `${productCode}.jpg`;
      const filepath = path.join(this.UPLOAD_DIR, filename);
      const tempPath = path.join(this.UPLOAD_DIR, `${productCode}.tmp`);

      try {
        // Raw dosyayƒ± kaydet
        await fs.writeFile(tempPath, buffer);

        // 1. ƒ∞lk deneme: Normal boyut (1200x1200)
        try {
          await this.convertWithImageMagick(tempPath, filepath);

          // Ba≈üarƒ±lƒ±!
          await fs.unlink(tempPath);
          const stats = await fs.stat(filepath);
          console.log(`‚úÖ Resim kaydedildi (1200px): ${productCode} (${(stats.size / 1024).toFixed(0)} KB)`);

          return {
            success: true,
            localPath: `/uploads/products/${filename}`,
            size: stats.size,
          };
        } catch (firstTryError: any) {
          console.log(`‚ö†Ô∏è 1200px ba≈üarƒ±sƒ±z (${productCode}), 800px deneniyor...`);

          // 2. ƒ∞kinci deneme: K√º√ß√ºk boyut (800x800)
          try {
            await this.convertWithImageMagick(tempPath, filepath, 800, 800);

            // Ba≈üarƒ±lƒ±!
            await fs.unlink(tempPath);
            const stats = await fs.stat(filepath);
            console.log(`‚úÖ Resim kaydedildi (800px): ${productCode} (${(stats.size / 1024).toFixed(0)} KB)`);

            return {
              success: true,
              localPath: `/uploads/products/${filename}`,
              size: stats.size,
            };
          } catch (secondTryError: any) {
            console.log(`‚ö†Ô∏è 800px ba≈üarƒ±sƒ±z (${productCode}), 600px deneniyor...`);

            // 3. Son deneme: √áok k√º√ß√ºk boyut (600x600)
            try {
              await this.convertWithImageMagick(tempPath, filepath, 600, 600);

              // Ba≈üarƒ±lƒ±!
              await fs.unlink(tempPath);
              const stats = await fs.stat(filepath);
              console.log(`‚úÖ Resim kaydedildi (600px): ${productCode} (${(stats.size / 1024).toFixed(0)} KB)`);

              return {
                success: true,
                localPath: `/uploads/products/${filename}`,
                size: stats.size,
              };
            } catch (thirdTryError: any) {
              // T√ºm denemeler ba≈üarƒ±sƒ±z
              throw thirdTryError;
            }
          }
        }
      } catch (imageMagickError: any) {
        // Temp dosyayƒ± temizle (varsa)
        try {
          await fs.unlink(tempPath);
        } catch {}

        // T√ºm y√∂ntemler ba≈üarƒ±sƒ±z
        console.error(`‚ùå T√ºm boyutlar ba≈üarƒ±sƒ±z (${productCode}):`, imageMagickError.message);

        return {
          success: false,
          skipped: true,
          skipReason: `Resim i≈ülenemedi - t√ºm boyutlar denendi`,
        };
      }
    } catch (error: any) {
      console.error(`‚ùå Resim indirme hatasƒ± (${productCode}):`, error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * T√ºm √ºr√ºnlerin resimlerini sync et (sadece resmi olmayanlara)
   */
  async syncAllImages(
    products: Array<{ id: string; mikroCode: string; name: string; guid: string; imageUrl: string | null }>,
    syncLogId?: string
  ): Promise<ImageSyncStats> {
    await this.ensureUploadDir();

    const stats: ImageSyncStats = {
      downloaded: 0,
      skipped: 0,
      failed: 0,
      warnings: [],
    };

    // Sadece resmi olmayan √ºr√ºnleri al
    const productsWithoutImage = products.filter(p => !p.imageUrl);
    const totalImages = productsWithoutImage.length;

    console.log(`\nüì∏ Resim senkronizasyonu ba≈ülƒ±yor: ${totalImages} √ºr√ºn`);

    // SyncLog'a toplam resim sayƒ±sƒ±nƒ± kaydet
    if (syncLogId) {
      const { prisma } = await import('../utils/prisma');
      await prisma.syncLog.update({
        where: { id: syncLogId },
        data: {
          details: {
            totalImages,
          },
        },
      });
    }

    for (const product of productsWithoutImage) {
      const result = await this.downloadImageFromMikro(product.mikroCode, product.guid);

      if (result.success && result.localPath) {
        stats.downloaded++;

        // PostgreSQL'de imageUrl g√ºncelle
        try {
          const { prisma } = await import('../utils/prisma');
          await prisma.product.update({
            where: { id: product.id },
            data: { imageUrl: result.localPath },
          });
        } catch (error: any) {
          console.error(`‚ùå ImageUrl g√ºncelleme hatasƒ± (${product.mikroCode}):`, error.message);
        }
      } else if (result.skipped) {
        stats.skipped++;

        // Uyarƒ± ekle (sadece boyut nedeniyle atlananlar i√ßin)
        if (result.size && result.size > this.MAX_IMAGE_SIZE) {
          stats.warnings.push({
            type: 'IMAGE_TOO_LARGE',
            productCode: product.mikroCode,
            productName: product.name,
            message: result.skipReason || 'Resim √ßok b√ºy√ºk',
            size: result.size,
          });
        }
      } else {
        stats.failed++;

        // Ger√ßek hata varsa uyarƒ± ekle
        if (result.error) {
          stats.warnings.push({
            type: 'IMAGE_DOWNLOAD_ERROR',
            productCode: product.mikroCode,
            productName: product.name,
            message: result.error,
          });
        }
      }

      // Her 10 √ºr√ºnde bir progress g√∂ster ve SyncLog'u g√ºncelle
      const processed = stats.downloaded + stats.skipped + stats.failed;
      if (processed % 10 === 0) {
        console.log(`  üìä ƒ∞lerleme: ${stats.downloaded} indirildi, ${stats.skipped} atlandƒ±, ${stats.failed} hata`);

        // SyncLog'u g√ºncelle
        if (syncLogId) {
          try {
            const { prisma } = await import('../utils/prisma');
            await prisma.syncLog.update({
              where: { id: syncLogId },
              data: {
                imagesDownloaded: stats.downloaded,
                imagesSkipped: stats.skipped,
                imagesFailed: stats.failed,
              },
            });
          } catch (error) {
            // G√ºncelleme hatasƒ±nƒ± logla ama devam et
            console.error('SyncLog g√ºncelleme hatasƒ±:', error);
          }
        }
      }
    }

    console.log(`\nüì∏ Resim senkronizasyonu tamamlandƒ±:`);
    console.log(`  ‚úÖ ƒ∞ndirilen: ${stats.downloaded}`);
    console.log(`  ‚è≠Ô∏è Atlanan: ${stats.skipped}`);
    console.log(`  ‚ùå Hatalƒ±: ${stats.failed}`);
    console.log(`  ‚ö†Ô∏è Uyarƒ± sayƒ±sƒ±: ${stats.warnings.length}`);

    return stats;
  }

  /**
   * Bir √ºr√ºn√ºn resmini sil
   */
  async deleteProductImage(imageUrl: string): Promise<void> {
    try {
      const filename = path.basename(imageUrl);
      const filepath = path.join(this.UPLOAD_DIR, filename);
      await fs.unlink(filepath);
      console.log(`üóëÔ∏è Resim silindi: ${filename}`);
    } catch (error: any) {
      console.error(`‚ùå Resim silme hatasƒ±:`, error.message);
    }
  }
}

export default new ImageService();
